<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>No-Mercy Card Match (UNO-No-Mercy Rules)</title>
  <style>
    :root{
      --bg:#0f1226;--card:#171a33;--muted:#9aa3b2;--accent:#7c5cff;--good:#22c55e;--bad:#ef4444;--warn:#f59e0b;--panel:#111428;
    }
    *{box-sizing:border-box}
    body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Arial; background:radial-gradient(60rem 60rem at 80% -10%,#23294f,transparent),radial-gradient(70rem 70rem at -10% 110%,#1b2040,transparent),var(--bg); color:#e6e8ef}
    .wrap{max-width:1100px;margin:0 auto;padding:24px}
    header{display:flex;align-items:center;justify-content:space-between;gap:16px;margin-bottom:12px;flex-wrap:wrap}
    h1{font-size:clamp(20px,4vw,28px);margin:0}
    .pill{padding:6px 10px;background:linear-gradient(135deg,#2a2e57,#1b1f3f);border:1px solid #2d325f;border-radius:999px;color:#cbd5e1;font-size:12px}
    .panel{background:linear-gradient(180deg,rgba(255,255,255,.03),rgba(255,255,255,.00));border:1px solid #2a2d52;border-radius:16px;padding:16px}
    .grid{display:grid;gap:16px}
    @media(min-width:880px){.grid{grid-template-columns:360px 1fr}}
    input,button,select{font:inherit}
    input[type=text]{width:100%;padding:10px 12px;border-radius:12px;border:1px solid #2a2d52;background:#0d1030;color:#e6e8ef}
    button{border:1px solid #2d325f;border-radius:12px;padding:10px 14px;background:#171a33;color:#e6e8ef;cursor:pointer}
    button.primary{background:linear-gradient(135deg,#6d5cff,#945cff);border-color:#7c5cff}
    button.ghost{background:transparent}
    button:disabled{opacity:.6;cursor:not-allowed}
    .row{display:flex;gap:10px;align-items:center;flex-wrap:wrap}
    .muted{color:var(--muted);font-size:13px}
    .label{font-size:12px;color:#cbd5e1;margin-bottom:6px}
    .invite{display:none;gap:8px;align-items:center;background:#12163a;border:1px solid #2a2d52;border-radius:12px;padding:8px 12px}
    .invite .code{font-weight:700;background:#0c1030;border:1px solid #2a2d52;border-radius:8px;padding:6px 10px}
    .warn{color:var(--warn)}
    .good{color:var(--good)}
    .bad{color:var(--bad)}
    .table{display:grid;gap:16px}
    @media(min-width:640px){.table{grid-template-columns: 1fr 320px}}
    .players{display:flex;flex-direction:column;gap:8px}
    .player{display:flex;align-items:center;justify-content:space-between;background:var(--panel);border:1px solid #272a50;border-radius:12px;padding:10px}
    .player.me{outline:2px solid var(--accent)}
    .player .name{font-weight:600}
    .badge{padding:2px 8px;border-radius:999px;border:1px solid #2d325f;background:#14173a;color:#cbd5e1;font-size:12px}
    .current{border-color:#9f7aea;box-shadow:0 0 0 2px rgba(124,92,255,.35) inset}

    .board{background:conic-gradient(from 0deg,#ff4d4d 0 25%,#3ecf8e 0 50%,#ffd166 0 75%,#60a5fa 0 100%);border-radius:16px;padding:14px}
    .board-inner{background:#0e1231b8;border:1px dashed #3a3f71;padding:16px;border-radius:12px;min-height:220px;display:grid;place-items:center}
    .pile{display:flex;gap:12px;align-items:center}

    .card{width:70px;height:110px;border-radius:12px;background:#fff;display:grid;place-items:center;color:#111;font-weight:800;font-size:28px;box-shadow:0 10px 24px rgba(0,0,0,.2);position:relative}
    .card .sym{font-size:36px}
    .card .tiny{position:absolute;top:6px;left:8px;font-size:12px;font-weight:700}
    .card.red{background:#ff4d4d;color:#fff}
    .card.green{background:#22c55e;color:#fff}
    .card.blue{background:#3b82f6;color:#fff}
    .card.yellow{background:#f59e0b;color:#111}
    .card.wild{background:linear-gradient(135deg,#222,#444);color:#fff}
    .card.outline{border:2px dashed #94a3b8;background:transparent;color:#94a3b8;box-shadow:none}

    .hand{display:flex;gap:8px;flex-wrap:wrap}
    .log{height:200px;overflow:auto;background:#0d1030;border:1px solid #2a2d52;border-radius:12px;padding:10px;font-size:13px}
    .small{font-size:12px}

    .toast{position:fixed;left:50%;bottom:18px;transform:translateX(-50%);background:#15183a;border:1px solid #2d325f;padding:10px 14px;border-radius:999px;color:#cbd5e1;box-shadow:0 10px 24px rgba(0,0,0,.3);display:none}
    .toast.show{display:block}

    .uno{background:#ef4444;border-color:#ef4444}
    .catch{background:#f59e0b;border-color:#f59e0b;color:#111}
    .kick{background:#ef4444;border-color:#7f1d1d}
  </style>
</head>
<body>
  <div class="wrap">
    <header>
      <h1>No-Mercy Card Match <span class="pill">UNO-No-Mercy • Cross-platform</span></h1>
      <div class="muted small">Host on GitHub Pages • Realtime via Firebase</div>
      <div id="inviteBar" class="invite">
        <span class="muted small">Room:</span>
        <span id="roomCode" class="code">—</span>
        <button id="copyInviteBtn">Copy invite link</button>
      </div>
    </header>

    <div class="grid">
      <section class="panel" id="lobbyPanel">
        <div class="label">Display name</div>
        <input id="nameInput" type="text" placeholder="e.g., Gaibul" />
        <div class="label" style="margin-top:12px">Create or join a room</div>
        <div class="row">
          <button class="primary" id="createRoomBtn">Create room</button>
          <input id="roomInput" type="text" placeholder="Enter room code" style="max-width:160px" />
          <button id="joinRoomBtn">Join</button>
          <button class="ghost" id="copyRoomBtn" title="Copy room link" disabled>Copy link</button>
        </div>
        <p class="muted small" style="margin-top:10px">Independent fan-made UNO-like. Not affiliated with Mattel.</p>
      </section>

      <section class="panel table" id="tablePanel" style="display:none">
        <div class="players" id="players"></div>
        <div>
          <div class="board">
            <div class="board-inner">
              <div>
                <div class="pile">
                  <div id="discardTop" class="card outline"><span class="tiny">DISC</span><span>–</span></div>
                  <div id="drawPile" class="card outline"><span class="tiny">DRAW</span><span>∞</span></div>
                </div>
                <div class="row" style="justify-content:center;margin-top:10px">
                  <button class="primary" id="startBtn">Start game</button>
                  <button id="drawBtn">Draw</button>
                  <button id="unoBtn" class="uno">UNO!</button>
                </div>
              </div>
            </div>
          </div>

          <h3 style="margin:14px 0 8px">Your hand</h3>
          <div class="hand" id="hand"></div>

          <h3 style="margin:14px 0 8px">Game log</h3>
          <div class="log" id="log"></div>
        </div>
      </section>
    </div>
  </div>

  <div class="toast" id="toast"></div>

  <!-- Firebase -->
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-app-compat.js"></script>
  <script src="https://www.gstatic.com/firebasejs/10.12.5/firebase-database-compat.js"></script>

  <script type="module">
    // 1) Firebase config
    const FIREBASE_CONFIG = {
      apiKey: "AIzaSyAEqutXCO5OZD6VU_ohaBxNfh7G8Q6PEy0",
      authDomain: "nomercy-8269a.firebaseapp.com",
      databaseURL: "https://nomercy-8269a-default-rtdb.asia-southeast1.firebasedatabase.app",
      projectId: "nomercy-8269a",
      storageBucket: "nomercy-8269a.firebasestorage.app",
      messagingSenderId: "349047620790",
      appId: "1:349047620790:web:3206ff81cb7f5413d29217",
      measurementId: "G-1WX7CWBFGF"
    };
    firebase.initializeApp(FIREBASE_CONFIG);
    const db = firebase.database();

    // 2) Helpers
    const $ = s => document.querySelector(s);
    const logEl = $('#log');
    function log(msg){ const p=document.createElement('div'); p.textContent=msg; logEl.appendChild(p); logEl.scrollTop=logEl.scrollHeight; }
    function toast(msg){ const t=$('#toast'); t.textContent=msg; t.classList.add('show'); setTimeout(()=>t.classList.remove('show'),1800); }
    function mod(a,b){return ((a%b)+b)%b}
    function uid(){return Math.random().toString(36).slice(2,9)}

    const COLORS = ['red','green','blue','yellow'];
    const VALUES = ['0','1','2','3','4','5','6','7','8','9','S','R','+2'];

    function drawValue(card){
      if(!card) return 0;
      if(card.t==='act' && card.v==='+2') return 2;
      if(card.t==='wild' && card.v && card.v.startsWith('+')) return parseInt(card.v.slice(1),10)||0;
      return 0;
    }

    function makeDeck(){
      const deck=[];
      for(const c of COLORS){
        deck.push({t:'num',c,v:'0'});
        for(const v of VALUES.filter(v=>v!=='0')){
          deck.push({t: v.match(/\+2|S|R/)?'act':'num', c, v});
          deck.push({t: v.match(/\+2|S|R/)?'act':'num', c, v});
        }
      }
      // Wilds
      for(let i=0;i<4;i++){ deck.push({t:'wild',v:'W'}); deck.push({t:'wild',v:'+4'}); }
      for(let i=0;i<4;i++) deck.push({t:'wild',v:'+6'});
      for(let i=0;i<2;i++) deck.push({t:'wild',v:'+10'});
      // Wild Color Roulette (WR) — add 4
      for(let i=0;i<4;i++) deck.push({t:'wild',v:'WR'}); 
      return shuffle(deck);
    }
    function shuffle(a){for(let i=a.length-1;i>0;i--){const j=Math.floor(Math.random()*(i+1));[a[i],a[j]]=[a[j],a[i]];}return a;}

    // 3) Local id/name
    let myId=localStorage.getItem('nm_me')||uid();
    localStorage.setItem('nm_me',myId);
    let myName=localStorage.getItem('nm_name')||'';
    $('#nameInput').value=myName;

    // 4) Room/session
    let roomId=null, isHost=false, unsub=null;

    const inviteBar = $('#inviteBar');
    const roomCodeEl = $('#roomCode');
    const copyInviteBtn = $('#copyInviteBtn');
    function updateInviteBar(){ if(!roomId){ inviteBar.style.display='none'; return; } roomCodeEl.textContent=roomId; inviteBar.style.display='flex'; }
    function currentInviteLink(){ return `${location.origin}${location.pathname}?room=${roomId}`; }
    copyInviteBtn.onclick = ()=>{ if(!roomId) return; navigator.clipboard.writeText(currentInviteLink()); toast('Invite link copied'); };

    // 5) Lobby actions
    $('#createRoomBtn').onclick=async()=>{
      myName = $('#nameInput').value.trim()||`Player_${myId.slice(0,4)}`;
      localStorage.setItem('nm_name',myName);
      const id=(Math.random().toString(36).slice(2,6)+Math.random().toString(36).slice(2,6)).toUpperCase();
      roomId=id; isHost=true;
      const base={
        created:Date.now(),
        host:myId,
        started:false,
        ended:false,
        endMsg:null,
        winner:null,
        loser:null,
        turn:0, dir:1, drawStack:0, currentColor:null,
        players:{},
        deck:[], discard:[]
      };
      await db.ref(`rooms/${roomId}`).set(base);
      await addPlayer();
      enterTable();
      updateInviteBar();
      try{ await navigator.clipboard.writeText(currentInviteLink()); toast('Invite link copied'); }catch{}
    };
    $('#joinRoomBtn').onclick=async()=>{
      const id=$('#roomInput').value.trim().toUpperCase();
      if(!id){toast('Enter a room code');return}
      const snap=await db.ref(`rooms/${id}`).get();
      if(!snap.exists()){toast('Room not found');return}
      roomId=id; isHost=(snap.val().host===myId);
      await addPlayer();
      enterTable();
      updateInviteBar();
    };
    $('#copyRoomBtn').onclick=()=>{ if(!roomId){toast('Create or join a room first');return;} navigator.clipboard.writeText(currentInviteLink()); toast('Invite link copied'); };

    async function addPlayer(){
      myName=$('#nameInput').value.trim()||`Player_${myId.slice(0,4)}`;
      localStorage.setItem('nm_name',myName);
      const p={id:myId,name:myName,hand:[],joined:Date.now(),unoReady:false};
      await db.ref(`rooms/${roomId}/players/${myId}`).set(p);
    }

    function enterTable(){
      $('#lobbyPanel').style.display='none';
      $('#tablePanel').style.display='grid';
      $('#startBtn').style.display = isHost? 'inline-block':'none';
      $('#copyRoomBtn').disabled=false;
      if(unsub) unsub();
      const ref=db.ref(`rooms/${roomId}`);
      const handler=(snap)=>{ if(!snap.exists()) return; const r=snap.val(); window._room=r; render(r); };
      ref.on('value',handler); unsub=()=>ref.off('value',handler);
      history.replaceState({},'',`?room=${roomId}`);
    }

    // Deep link prefill
    (function(){ const u=new URL(location.href); const rid=u.searchParams.get('room'); if(rid){ $('#roomInput').value=rid; } })();

    // 6) Start game
    $('#startBtn').onclick=async()=>{
      const rRef=db.ref(`rooms/${roomId}`); const snap=await rRef.get(); const r=snap.val();
      if(!isHost){ toast('Only host can start'); return }
      const ids=Object.keys(r.players||{}); if(ids.length<2){ toast('Need at least 2 players'); return }
      let deck=makeDeck();
      for(const pid of ids){ r.players[pid].hand=[]; r.players[pid].unoReady=false; }
      for(let i=0;i<7;i++) for(const pid of ids){ r.players[pid].hand.push(deck.pop()) }
      let first=deck.pop();
      while(first.t==='wild' || (first.t==='act' && first.v.match(/S|R|\+2/))){ deck.unshift(first); deck=shuffle(deck); first=deck.pop(); }
      r.discard=[first]; r.currentColor=first.c; r.turn=0; r.dir=1; r.drawStack=0; r.started=true; r.ended=false; r.endMsg=null; r.winner=null; r.loser=null; r.deck=deck;
      await rRef.set(r); log('Game started');
    };

    // 7) Buttons
    $('#drawBtn').onclick=()=> doDraw();
    $('#unoBtn').onclick=()=> setUnoReady();

    async function setUnoReady(){
      const ref=db.ref(`rooms/${roomId}/players/${myId}/unoReady`);
      await ref.set(true); toast('UNO armed for this turn');
    }

    function refillDeck(r){
      if(r.deck.length===0){
        const top=r.discard.pop();
        r.deck=shuffle(r.discard);
        r.discard=[top];
      }
    }

    function checkEndStates(r){
      const ids=Object.keys(r.players||{});
      for(const pid of ids){
        const p=r.players[pid];
        if(p.hand.length>=25 && !r.ended){
          r.ended=true; r.loser=pid; r.endMsg=`${p.name||pid} reached 25 cards and LOSES!`;
        }
      }
      return r;
    }

    async function doDraw(){
      const rRef=db.ref(`rooms/${roomId}`);
      await rRef.transaction(r=>{
        if(!r||!r.started||r.ended) return r;
        const ids=Object.keys(r.players||{}); if(ids.length===0) return r;
        const cur=ids[r.turn]; if(cur!==myId) return r;
        const n = r.drawStack>0? r.drawStack : 1;
        for(let i=0;i<n;i++){
          refillDeck(r);
          r.players[cur].hand.push(r.deck.pop());
        }
        r.players[cur].unoReady=false;
        r.drawStack=0;

        // Ensure we still apply the loss AFTER the full draw is completed
        r = checkEndStates(r);
        if(r.ended) return r;

        r.turn = mod(r.turn + r.dir, ids.length);
        return r;
      });
    }

    // 8) Rules helpers
    function canPlay(card, top, currentColor, r){
      if(!r||!card) return false;
      if(r.ended) return false;
      // Active draw stack: only allow draw cards; must be >= last draw value
      if(r.drawStack>0){
        const last = r.discard[r.discard.length-1];
        const lastDV = drawValue(last);
        const dv = drawValue(card);
        return dv>0 && dv>=lastDV;
      }
      if(card.t==='wild') return true;
      if(card.c===currentColor) return true;
      if(top && top.t==='wild'){ return card.c===currentColor; }
      if(top && card.c===top.c) return true;
      if(top && card.v===top.v) return true;
      return false;
    }

    // Swap helper (7)
    function swapHands(r, pidA, pidB){
      const a = r.players[pidA].hand;
      const b = r.players[pidB].hand;
      r.players[pidA].hand = JSON.parse(JSON.stringify(b));
      r.players[pidB].hand = JSON.parse(JSON.stringify(a));
    }

    // Rotate helper (0)
    function rotateHands(r){
      const ids=Object.keys(r.players||{});
      const hands = ids.map(pid=> r.players[pid].hand);
      const n=ids.length;
      for(let i=0;i<n;i++){
        const src = (r.dir===1)? mod(i-1,n) : mod(i+1,n);
        r.players[ids[i]].hand = JSON.parse(JSON.stringify(hands[src]));
      }
    }

    function pickColorPrompt(defaultColor){
      const msg = 'Pick a color: R=red, G=green, B=blue, Y=yellow';
      const map = {r:'red', g:'green', b:'blue', y:'yellow'};
      let ans = prompt(msg, (defaultColor||'red')[0]);
      if(!ans) return defaultColor||'red';
      ans = ans.trim().toLowerCase()[0];
      return map[ans] || defaultColor || 'red';
    }

    async function playCard(idx, chooseColor, swapTargetPid){
      const rRef=db.ref(`rooms/${roomId}`);
      await rRef.transaction(r=>{
        if(!r||!r.started||r.ended) return r;
        const ids=Object.keys(r.players||{}); if(ids.length===0) return r;
        const curIdx=r.turn; const cur=ids[curIdx]; if(cur!==myId) return r;
        const hand=r.players[cur].hand; const card=hand[idx]; if(!card) return r;

        const top=r.discard[r.discard.length-1];
        const currentColor=r.currentColor || top?.c;
        if(!canPlay(card, top, currentColor, r)) return r;

        // Remove card and push to discard
        hand.splice(idx,1);
        r.discard.push(card);

        // Apply effects
        if(r.drawStack>0){
          // Only draw cards reach here; add to stack
          r.drawStack += drawValue(card);
          if(card.t==='wild'){ r.currentColor = chooseColor || pickColorPrompt(r.currentColor||'red'); }
        } else {
          if(card.t==='wild'){
            const picked = chooseColor || pickColorPrompt(r.currentColor||'red');
            r.currentColor = picked;
            if(card.v==='+4' || card.v==='+6' || card.v==='+10'){
              r.drawStack += drawValue(card);
            }
            // Wild Color Roulette — robust version with escape hatch
            if(card.v==='WR'){
              const nextIdx = mod(curIdx + r.dir, ids.length);
              const nxt = ids[nextIdx];
              let draws=0;
              // Guard limit: draw at most total cards available + 2 reshuffles
              const hardCap = (r.deck.length + r.discard.length + 108);
              while(draws <= hardCap){
                refillDeck(r);
                const d = r.deck.pop();
                r.players[nxt].hand.push(d);
                draws++;
                if(d.c===r.currentColor){ break; }
              }
              // End victim's turn immediately; advance to following player
              r.turn = mod(nextIdx + r.dir, ids.length);
              // Clear UNO on both actors
              r.players[cur].unoReady=false;
              r.players[nxt].unoReady=false;

              // If WR caused someone to hit 25+, end now
              r = checkEndStates(r);
              return r;
            }
          } else {
            r.currentColor = card.c;
            if(card.t==='act'){
              if(card.v==='S'){ r.turn = mod(r.turn + r.dir, ids.length); } // skip next
              if(card.v==='R'){ r.dir = -r.dir; if(ids.length===2){ r.turn = mod(r.turn + r.dir, ids.length); } }
              if(card.v==='+2'){ r.drawStack += 2; }
            }
            // Special number rules
            if(card.t==='num'){
              if(card.v==='7'){
                // swap with chosen target if valid and not self
                if(swapTargetPid && r.players[swapTargetPid] && swapTargetPid!==cur){
                  swapHands(r, cur, swapTargetPid);
                }
              }
              if(card.v==='0'){
                rotateHands(r);
              }
            }
          }
        }

        // UNO handling
        if(r.players[cur].hand.length===1){
          if(r.players[cur].unoReady){ r.players[cur].unoReady=false; }
          else { r.catchable = cur; }
        } else { r.catchable = null; }

        // End states (win / 25-card loss)
        if(r.players[cur].hand.length===0 && !r.ended){
          r.ended=true; r.winner=cur; r.endMsg=`${r.players[cur].name||cur} has WON the game!`;
        }
        r = checkEndStates(r);
        if(r.ended) return r;

        // Advance turn (unless already advanced by WR)
        r.turn = mod(r.turn + r.dir, ids.length);
        return r;
      });
    }

    // 9) Kick player (host-only)
    async function kickPlayer(pid){
      const rRef=db.ref(`rooms/${roomId}`);
      await rRef.transaction(r=>{
        if(!r) return r;
        if(r.host!==myId) return r; // only host
        if(!r.players || !r.players[pid]) return r;
        const ids=Object.keys(r.players);
        const kickedIndex = ids.indexOf(pid);
        // Adjust turn if needed
        if(r.started){
          if(kickedIndex===r.turn){
            // move turn to next player in same direction
            const remaining = ids.filter(x=>x!==pid);
            if(remaining.length>0){
              const nextIndex = mod(kickedIndex + r.dir, ids.length);
              const nextPid = ids[nextIndex]===pid ? remaining[0] : ids[nextIndex];
              r.turn = remaining.indexOf(nextPid);
            } else {
              r.turn = 0;
            }
          } else if(kickedIndex < r.turn){
            r.turn = Math.max(0, r.turn-1);
          }
        }
        delete r.players[pid];

        // If only one player remains in a started game, declare winner
        const left = Object.keys(r.players||{});
        if(r.started && left.length===1 && !r.ended){
          r.ended=true; r.winner=left[0]; r.endMsg=`${r.players[left[0]].name||left[0]} is the last player standing and WINS!`;
        }
        return r;
      });
      toast('Player removed');
    }

    // 10) Rendering
    function render(r){
      const ids=Object.keys(r.players||{});
      const playersEl=$('#players'); playersEl.innerHTML='';
      ids.forEach((pid,i)=>{
        const p=r.players[pid];
        const div=document.createElement('div'); div.className='player'+(pid===myId?' me':'')+(r.started && i===r.turn?' current':'');
        const left=document.createElement('div'); left.className='row';
        const nm=document.createElement('div'); nm.className='name'; nm.textContent=p.name||pid;
        left.append(nm);
        const right=document.createElement('div'); right.className='row';
        const cards=document.createElement('div'); cards.className='badge'; cards.textContent=(p.hand?.length||0)+' cards';
        right.append(cards);

        // Host can kick others
        if(r.host===myId && pid!==myId){
          const k=document.createElement('button'); k.className='kick'; k.textContent='Kick';
          k.onclick=()=>{
            if(confirm(`Remove ${p.name||pid} from the room?`)){
              kickPlayer(pid);
            }
          };
          right.append(k);
        }

        if(pid!==myId && r.started && (p.hand?.length===1) && !p.unoReady){
          const btn=document.createElement('button'); btn.className='catch'; btn.textContent='Catch UNO';
          btn.onclick=()=>catchUNO(pid);
          right.append(btn);
        }
        div.append(left,right);
        playersEl.append(div);
      });

      const top=r.discard?.[r.discard.length-1];
      const topEl=$('#discardTop');
      if(top){
        topEl.className=`card ${top.t==='wild'?'wild':top.c}`;
        topEl.innerHTML=`<span class="tiny">DISC</span><span class="sym">${top.v||''}</span>`;
      } else {
        topEl.className='card outline'; topEl.innerHTML='<span class="tiny">DISC</span><span>–</span>';
      }
      const drawEl=$('#drawPile');
      drawEl.onclick=()=> $('#drawBtn').click();

      $('#startBtn').style.display = (isHost && !r.started)? 'inline-block':'none';
      $('#drawBtn').style.display = r.started? 'inline-block':'none';
      $('#unoBtn').style.display  = r.started? 'inline-block':'none';
      if(r.ended){ $('#drawBtn').disabled=true; }

      const me=r.players?.[myId];
      const handEl=$('#hand'); handEl.innerHTML='';
      const currentColor=r.currentColor || top?.c;
      const myTurn = r.started && !r.ended && ids[r.turn]===myId;

      me?.hand?.forEach((card,idx)=>{
        const b=document.createElement('button'); b.className='card '+(card.t==='wild'?'wild':card.c);
        b.innerHTML=`<span class="tiny">YOU</span><span class="sym">${card.v}</span>`;
        b.disabled = !(myTurn && canPlay(card, top, currentColor, r));
        b.onclick=()=>{
          // Wilds: prompt color directly (more reliable than dropdown)
          if(card.t==='wild'){
            const color = pickColorPrompt(currentColor||'red');
            playCard(idx,color);
            return;
          }
          // 7: prompt for target player
          if(card.t==='num' && card.v==='7'){
            const others = ids.filter(pid=>pid!==myId);
            if(others.length===0){ playCard(idx); return; }
            const label = others.map((pid,i)=>`${i+1}. ${r.players[pid].name||pid}`).join('\n');
            const ans = prompt(`Choose a player to swap with:\n${label}\nEnter number (1-${others.length})`);
            const n = parseInt(ans,10);
            if(!n || n<1 || n>others.length){ toast('Swap cancelled'); return; }
            const target = others[n-1];
            playCard(idx,null,target);
            return;
          }
          // Normal play
          playCard(idx);
        };
        handEl.appendChild(b);
      });

      // Draw pile label for active drawStack
      if(r.drawStack>0){
        drawEl.classList.remove('outline');
        drawEl.innerHTML = `<span class="tiny">DRAW</span><span class="sym">+${r.drawStack}</span>`;
      } else {
        drawEl.classList.add('outline');
        drawEl.innerHTML = `<span class="tiny">DRAW</span><span>∞</span>`;
      }

      // End message to log once
      if(r.ended && r.endMsg && !render._announcedEnd){
        log(r.endMsg);
        toast(r.endMsg);
        render._announcedEnd = true;
      }
      if(!r.ended){ render._announcedEnd = false; }
    }

    // 11) Catch UNO action
    async function catchUNO(pid){
      const rRef=db.ref(`rooms/${roomId}`);
      await rRef.transaction(r=>{
        if(!r||!r.started||r.ended) return r;
        const p=r.players?.[pid]; if(!p) return r;
        if((p.hand?.length||0)!==1) return r; // no longer valid
        if(p.unoReady) return r; // they armed UNO
        for(let i=0;i<2;i++){
          refillDeck(r);
          p.hand.push(r.deck.pop());
        }
        p.unoReady=false;
        // If catch pushes over 25, end immediately
        r = checkEndStates(r);
        return r;
      });
      log('UNO caught! +2 applied.');
    }

  </script>
</body>
</html>
